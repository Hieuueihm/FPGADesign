LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
use IEEE.NUMERIC_STD.ALL;


ENTITY FIR IS
    GENERIC (
        FILTER_TAPS : INTEGER := 11;
        INPUT_WIDTH : INTEGER RANGE 8 TO 32 := 8;
        COEF_WIDTH : INTEGER RANGE 8 TO 32 := 8;
        OUTPUT_WIDTH : INTEGER RANGE 8 TO 32 := 16 -- <COEF_WIDTH + INPUT_WIDTH - 1>
    );
    PORT (
        clk : IN STD_LOGIC;
        rst : IN STD_LOGIC;
        start : IN STD_LOGIC;
        --OUTPUTS
        Din : IN STD_LOGIC_VECTOR(INPUT_WIDTH - 1 DOWNTO 0);
        Dout : OUT STD_LOGIC_VECTOR(OUTPUT_WIDTH - 1 DOWNTO 0);
        Done : OUT STD_LOGIC

    );
END ENTITY FIR;

ARCHITECTURE Behavioral OF FIR IS
    TYPE input_registers IS ARRAY(0 TO FILTER_TAPS - 1) OF signed(INPUT_WIDTH - 1 DOWNTO 0);
    SIGNAL delay_line_s : input_registers := (OTHERS => (OTHERS => '0'));

    TYPE COEFFICIENT_TYPE IS ARRAY (0 TO FILTER_TAPS - 1) OF signed(COEF_WIDTH - 1 DOWNTO 0);
    CONSTANT coefficients : COEFFICIENT_TYPE :=
    (X"F1",
    X"F3",
    X"07",
    X"26",
    X"42",
    X"4E",
    X"42",
    X"26",
    X"07",
    X"F3",
    X"F1"
    );

    SIGNAL start_delay : STD_LOGIC := 'X'; -- to determine the rising edge of start 
    TYPE FSM IS (IDLE, ACTIVE, DONEIT);
    SIGNAL STATE : FSM;
    SIGNAL data_out : signed(INPUT_WIDTH + COEF_WIDTH - 1 DOWNTO 0);
    SIGNAL accumulator : signed(INPUT_WIDTH + COEF_WIDTH - 1 DOWNTO 0);
    SIGNAL current_taps : INTEGER RANGE 0 TO FILTER_TAPS - 1;

BEGIN
    Dout <= STD_LOGIC_VECTOR(data_out(INPUT_WIDTH + COEF_WIDTH - 2 DOWNTO INPUT_WIDTH + COEF_WIDTH - OUTPUT_WIDTH - 1));
    FIRProcess : PROCESS (clk, rst)
        VARIABLE sum : signed(INPUT_WIDTH + COEF_WIDTH - 1 DOWNTO 0);
    BEGIN
        IF rst = '1' THEN
            Done <= '0';
            data_out <= (OTHERS => '0');
            accumulator <= (OTHERS => '0');
            current_taps <= FILTER_TAPS - 1;
            delay_line_s <= signed(Din);
            sum := (OTHERS => '0');
        ELSIF rising_edge(clk) THEN
            start_delay <= start;
            CASE STATE IS
                WHEN IDLE =>
                    IF start = '1' AND start_delay <= '0' THEN
                        STATE <= ACTIVE;
                    END IF;
                WHEN ACTIVE =>
                    IF current_taps > 0 THEN
                        delay_line_s(current_taps) <= delay_line_s(current_taps - 1);
                        sum := delay_line_s(current_taps) * coefficients(current_taps);
                        accumulator <= accumulator + sum;
                    ELSE
                        STATE <= DONEIT;
                    END IF;
                WHEN DONEIT =>
                    Done <= '1';
                    STATE <= IDLE;
                WHEN OTHERS =>
                    STATE <= IDLE;
            END CASE;

        END IF;
    END PROCESS;

END ARCHITECTURE Behavioral;